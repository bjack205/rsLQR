<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rsLQR: rsLQR Solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rsLQR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rsLQR Solver</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUnitRange.html">UnitRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range of consecutive integers.  <a href="structUnitRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryNode__s.html">BinaryNode_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary tree for the rsLQR solver.  <a href="structOrderedBinaryTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a list of <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> structs for the rsLQR solver.  <a href="structNdLqrCholeskyFactors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNdFactor.html">NdFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chunk of memory for a single time step.  <a href="structNdFactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNdData.html">NdData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core storage container for the rsLQR solver.  <a href="structNdData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct describing how long each part of the solve took, in milliseconds.  <a href="structNdLqrProfile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main solver for rsLQR.  <a href="structNdLqrSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga532315ee0795052537eafde38f7339dc"><td class="memItemLeft" align="right" valign="top"><a id="ga532315ee0795052537eafde38f7339dc" name="ga532315ee0795052537eafde38f7339dc"></a>
typedef struct <a class="el" href="structBinaryNode__s.html">BinaryNode_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryNode</b></td></tr>
<tr class="memdesc:ga532315ee0795052537eafde38f7339dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the nodes in the binary tree for the rsLQR solver. <br /></td></tr>
<tr class="separator:ga532315ee0795052537eafde38f7339dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga58621bd1feb25e3dee120e49c6451172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga58621bd1feb25e3dee120e49c6451172">ndlqr_BuildTree</a> (int N)</td></tr>
<tr class="memdesc:ga58621bd1feb25e3dee120e49c6451172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new binary tree for a horizon of length <code>N</code>.  <a href="group__rsLQR.html#ga58621bd1feb25e3dee120e49c6451172">More...</a><br /></td></tr>
<tr class="separator:ga58621bd1feb25e3dee120e49c6451172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f22c532856661f4d072692b803eb5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga88f22c532856661f4d072692b803eb5d">ndlqr_FreeTree</a> (<a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *tree)</td></tr>
<tr class="memdesc:ga88f22c532856661f4d072692b803eb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the data in <code>tree</code>.  <a href="group__rsLQR.html#ga88f22c532856661f4d072692b803eb5d">More...</a><br /></td></tr>
<tr class="separator:ga88f22c532856661f4d072692b803eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7091ad6eed6a6a2dc0e77f6c04a54529"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga7091ad6eed6a6a2dc0e77f6c04a54529">ndlqr_GetIndexFromLeaf</a> (const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *tree, int leaf, int level)</td></tr>
<tr class="memdesc:ga7091ad6eed6a6a2dc0e77f6c04a54529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the knot point index given the leaf index at a given level.  <a href="group__rsLQR.html#ga7091ad6eed6a6a2dc0e77f6c04a54529">More...</a><br /></td></tr>
<tr class="separator:ga7091ad6eed6a6a2dc0e77f6c04a54529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fac162ee700642c4c323bfec422a65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gaf2fac162ee700642c4c323bfec422a65">ndlqr_GetIndexLevel</a> (const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *tree, int index)</td></tr>
<tr class="memdesc:gaf2fac162ee700642c4c323bfec422a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the level for a given knot point index.  <a href="group__rsLQR.html#gaf2fac162ee700642c4c323bfec422a65">More...</a><br /></td></tr>
<tr class="separator:gaf2fac162ee700642c4c323bfec422a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb47b122d55cdbb5d44e3d61fa39c07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gadbb47b122d55cdbb5d44e3d61fa39c07">ndlqr_GetIndexAtLevel</a> (const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *tree, int index, int level)</td></tr>
<tr class="memdesc:gadbb47b122d55cdbb5d44e3d61fa39c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index in <code>level</code> that corresponds to <code>index</code>.  <a href="group__rsLQR.html#gadbb47b122d55cdbb5d44e3d61fa39c07">More...</a><br /></td></tr>
<tr class="separator:gadbb47b122d55cdbb5d44e3d61fa39c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afa3d33bd0a5a7853434a2ddf084f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga0afa3d33bd0a5a7853434a2ddf084f7e">ndlqr_NewCholeskyFactors</a> (int depth, int nhorizon)</td></tr>
<tr class="memdesc:ga0afa3d33bd0a5a7853434a2ddf084f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new <a class="el" href="structNdLqrCholeskyFactors.html" title="Stores a list of CholeskyInfo structs for the rsLQR solver.">NdLqrCholeskyFactors</a> object.  <a href="group__rsLQR.html#ga0afa3d33bd0a5a7853434a2ddf084f7e">More...</a><br /></td></tr>
<tr class="separator:ga0afa3d33bd0a5a7853434a2ddf084f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347fabdfc15bad96109ec07ac581afa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga347fabdfc15bad96109ec07ac581afa8">ndlqr_FreeCholeskyFactors</a> (<a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *cholfacts)</td></tr>
<tr class="memdesc:ga347fabdfc15bad96109ec07ac581afa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory of a CholeskyFactors object.  <a href="group__rsLQR.html#ga347fabdfc15bad96109ec07ac581afa8">More...</a><br /></td></tr>
<tr class="separator:ga347fabdfc15bad96109ec07ac581afa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68ab5c2128682cbf8fdd451f238a0c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gab68ab5c2128682cbf8fdd451f238a0c6">ndlqr_GetQFactorizon</a> (<a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *cholfacts, int index, <a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **cholfact)</td></tr>
<tr class="memdesc:gab68ab5c2128682cbf8fdd451f238a0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the matrix Q at index <code>index</code>.  <a href="group__rsLQR.html#gab68ab5c2128682cbf8fdd451f238a0c6">More...</a><br /></td></tr>
<tr class="separator:gab68ab5c2128682cbf8fdd451f238a0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2966cbba0933c886aea12854d967dd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gae2966cbba0933c886aea12854d967dd2">ndlqr_GetRFactorizon</a> (<a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *cholfacts, int index, <a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **cholfact)</td></tr>
<tr class="memdesc:gae2966cbba0933c886aea12854d967dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the matrix R at index <code>index</code>.  <a href="group__rsLQR.html#gae2966cbba0933c886aea12854d967dd2">More...</a><br /></td></tr>
<tr class="separator:gae2966cbba0933c886aea12854d967dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d1d95ede3b3b83a19f7b6edeba0a44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga98d1d95ede3b3b83a19f7b6edeba0a44">ndlqr_GetSFactorization</a> (<a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *cholfacts, int leaf, int level, <a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **cholfact)</td></tr>
<tr class="memdesc:ga98d1d95ede3b3b83a19f7b6edeba0a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the output of <a class="el" href="group__rsLQR.html#ga2ab24570b3c8d44f764224ef99dfb4b6" title="Use the precomputed Cholesky factorization to solve for y at each parent level.">ndlqr_SolveCholeskyFactor()</a>.  <a href="group__rsLQR.html#ga98d1d95ede3b3b83a19f7b6edeba0a44">More...</a><br /></td></tr>
<tr class="separator:ga98d1d95ede3b3b83a19f7b6edeba0a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c821262db520680371c009083460f23"><td class="memItemLeft" align="right" valign="top"><a id="ga3c821262db520680371c009083460f23" name="ga3c821262db520680371c009083460f23"></a>
<a class="el" href="structMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_GetLambdaFactor</b> (<a class="el" href="structNdFactor.html">NdFactor</a> *factor)</td></tr>
<tr class="separator:ga3c821262db520680371c009083460f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c22a7c9ac55b764c146d774a38443d6"><td class="memItemLeft" align="right" valign="top"><a id="ga5c22a7c9ac55b764c146d774a38443d6" name="ga5c22a7c9ac55b764c146d774a38443d6"></a>
<a class="el" href="structMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_GetStateFactor</b> (<a class="el" href="structNdFactor.html">NdFactor</a> *factor)</td></tr>
<tr class="separator:ga5c22a7c9ac55b764c146d774a38443d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444815d77aef521adf1cedca842c4cc8"><td class="memItemLeft" align="right" valign="top"><a id="ga444815d77aef521adf1cedca842c4cc8" name="ga444815d77aef521adf1cedca842c4cc8"></a>
<a class="el" href="structMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_GetInputFactor</b> (<a class="el" href="structNdFactor.html">NdFactor</a> *factor)</td></tr>
<tr class="separator:ga444815d77aef521adf1cedca842c4cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a8b869c8f653a598474393a5f95630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNdData.html">NdData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga48a8b869c8f653a598474393a5f95630">ndlqr_NewNdData</a> (int nstates, int ninputs, int nhorizon, int width)</td></tr>
<tr class="memdesc:ga48a8b869c8f653a598474393a5f95630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure.  <a href="group__rsLQR.html#ga48a8b869c8f653a598474393a5f95630">More...</a><br /></td></tr>
<tr class="separator:ga48a8b869c8f653a598474393a5f95630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d99f612df1652c82044835c16e96e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga39d99f612df1652c82044835c16e96e5">ndlqr_FreeNdData</a> (<a class="el" href="structNdData.html">NdData</a> *nddata)</td></tr>
<tr class="memdesc:ga39d99f612df1652c82044835c16e96e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated in an <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure.  <a href="group__rsLQR.html#ga39d99f612df1652c82044835c16e96e5">More...</a><br /></td></tr>
<tr class="separator:ga39d99f612df1652c82044835c16e96e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae7f8de9bb4013d3800c5795f07930b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga9ae7f8de9bb4013d3800c5795f07930b">ndlqr_GetNdFactor</a> (<a class="el" href="structNdData.html">NdData</a> *nddata, int index, int level, <a class="el" href="structNdFactor.html">NdFactor</a> **factor)</td></tr>
<tr class="memdesc:ga9ae7f8de9bb4013d3800c5795f07930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an individual <a class="el" href="structNdFactor.html" title="A chunk of memory for a single time step.">NdFactor</a> out of the <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a>.  <a href="group__rsLQR.html#ga9ae7f8de9bb4013d3800c5795f07930b">More...</a><br /></td></tr>
<tr class="separator:ga9ae7f8de9bb4013d3800c5795f07930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc6e77a65cf48a86f5e951a69cfe78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gaefc6e77a65cf48a86f5e951a69cfe78b">ndlqr_ResetNdData</a> (<a class="el" href="structNdData.html">NdData</a> *nddata)</td></tr>
<tr class="memdesc:gaefc6e77a65cf48a86f5e951a69cfe78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all of the memory for an <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> to zero.  <a href="group__rsLQR.html#gaefc6e77a65cf48a86f5e951a69cfe78b">More...</a><br /></td></tr>
<tr class="separator:gaefc6e77a65cf48a86f5e951a69cfe78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87139e9514629e7e355f75f3267e72dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga87139e9514629e7e355f75f3267e72dc">ndlqr_SolveLeaf</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver, int index)</td></tr>
<tr class="memdesc:ga87139e9514629e7e355f75f3267e72dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve all the equations for the lowest-level diagonal blocks, by timestep.  <a href="group__rsLQR.html#ga87139e9514629e7e355f75f3267e72dc">More...</a><br /></td></tr>
<tr class="separator:ga87139e9514629e7e355f75f3267e72dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a9c80d8634bf55509544f16631675a"><td class="memItemLeft" align="right" valign="top"><a id="gae8a9c80d8634bf55509544f16631675a" name="gae8a9c80d8634bf55509544f16631675a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_SolveLeaves</b> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="separator:gae8a9c80d8634bf55509544f16631675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b4290a3055f2e214a78189fe4ad490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gab8b4290a3055f2e214a78189fe4ad490">ndlqr_FactorInnerProduct</a> (<a class="el" href="structNdData.html">NdData</a> *data, <a class="el" href="structNdData.html">NdData</a> *fact, int index, int data_level, int fact_level)</td></tr>
<tr class="memdesc:gab8b4290a3055f2e214a78189fe4ad490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates one of the inner products needed at level <code>data_level</code>.  <a href="group__rsLQR.html#gab8b4290a3055f2e214a78189fe4ad490">More...</a><br /></td></tr>
<tr class="separator:gab8b4290a3055f2e214a78189fe4ad490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab24570b3c8d44f764224ef99dfb4b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga2ab24570b3c8d44f764224ef99dfb4b6">ndlqr_SolveCholeskyFactor</a> (<a class="el" href="structNdData.html">NdData</a> *fact, <a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> *cholinfo, int index, int level, int upper_level)</td></tr>
<tr class="memdesc:ga2ab24570b3c8d44f764224ef99dfb4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the precomputed Cholesky factorization to solve for y at each parent level.  <a href="group__rsLQR.html#ga2ab24570b3c8d44f764224ef99dfb4b6">More...</a><br /></td></tr>
<tr class="separator:ga2ab24570b3c8d44f764224ef99dfb4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9cd59f37a777094d6fe96711afb25c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga7b9cd59f37a777094d6fe96711afb25c">ndlqr_ShouldCalcLambda</a> (<a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *tree, int index, int i)</td></tr>
<tr class="memdesc:ga7b9cd59f37a777094d6fe96711afb25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the \( \Lambda \) should be updated during ndlqr_UpdateSchurFactor()  <a href="group__rsLQR.html#ga7b9cd59f37a777094d6fe96711afb25c">More...</a><br /></td></tr>
<tr class="separator:ga7b9cd59f37a777094d6fe96711afb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f6b5fe4556a7ea57686566d0922ff9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga92f6b5fe4556a7ea57686566d0922ff9">ndlqr_UpdateShurFactor</a> (<a class="el" href="structNdData.html">NdData</a> *fact, <a class="el" href="structNdData.html">NdData</a> *soln, int index, int i, int level, int upper_level, bool calc_lambda)</td></tr>
<tr class="memdesc:ga92f6b5fe4556a7ea57686566d0922ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \( x \) and \( z \) to complete the factorization at the current level.  <a href="group__rsLQR.html#ga92f6b5fe4556a7ea57686566d0922ff9">More...</a><br /></td></tr>
<tr class="separator:ga92f6b5fe4556a7ea57686566d0922ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70aa2a0a81f96c9e1a270b289f46e745"><td class="memItemLeft" align="right" valign="top"><a id="ga70aa2a0a81f96c9e1a270b289f46e745" name="ga70aa2a0a81f96c9e1a270b289f46e745"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_ComputeShurCompliment</b> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver, int index, int level, int upper_level)</td></tr>
<tr class="separator:ga70aa2a0a81f96c9e1a270b289f46e745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee14a10200c2d84096964703030dda2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2">ndlqr_Solve</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga3ee14a10200c2d84096964703030dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an LQR problem using rsLQR.  <a href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2">More...</a><br /></td></tr>
<tr class="separator:ga3ee14a10200c2d84096964703030dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01780b3bc4f5f408ddee594e74106f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga01780b3bc4f5f408ddee594e74106f58">ndlqr_GetSolution</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga01780b3bc4f5f408ddee594e74106f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution vector.  <a href="group__rsLQR.html#ga01780b3bc4f5f408ddee594e74106f58">More...</a><br /></td></tr>
<tr class="separator:ga01780b3bc4f5f408ddee594e74106f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec8f7acf834c55596d31eeab7502639"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga6ec8f7acf834c55596d31eeab7502639">ndlqr_CopySolution</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver, double *soln)</td></tr>
<tr class="memdesc:ga6ec8f7acf834c55596d31eeab7502639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the solution vector to a user-supplied array.  <a href="group__rsLQR.html#ga6ec8f7acf834c55596d31eeab7502639">More...</a><br /></td></tr>
<tr class="separator:ga6ec8f7acf834c55596d31eeab7502639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b72898fba663c7767386460de2103b"><td class="memItemLeft" align="right" valign="top"><a id="gaa8b72898fba663c7767386460de2103b" name="gaa8b72898fba663c7767386460de2103b"></a>
<a class="el" href="structNdLqrProfile.html">NdLqrProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ndlqr_NewNdLqrProfile</b> ()</td></tr>
<tr class="memdesc:gaa8b72898fba663c7767386460de2103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a profile initialized with zeros. <br /></td></tr>
<tr class="separator:gaa8b72898fba663c7767386460de2103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4588eb322de417b184ff7e6df976b0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga4588eb322de417b184ff7e6df976b0fe">ndlqr_ResetProfile</a> (<a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *prof)</td></tr>
<tr class="memdesc:ga4588eb322de417b184ff7e6df976b0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the profile to its initialized state.  <a href="group__rsLQR.html#ga4588eb322de417b184ff7e6df976b0fe">More...</a><br /></td></tr>
<tr class="separator:ga4588eb322de417b184ff7e6df976b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e23fb27df1efa3aa041f76d8b42237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga55e23fb27df1efa3aa041f76d8b42237">ndlqr_CopyProfile</a> (<a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *dest, <a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *src)</td></tr>
<tr class="memdesc:ga55e23fb27df1efa3aa041f76d8b42237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the profile information to a new profile.  <a href="group__rsLQR.html#ga55e23fb27df1efa3aa041f76d8b42237">More...</a><br /></td></tr>
<tr class="separator:ga55e23fb27df1efa3aa041f76d8b42237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96a6ad46dd8363ce5d2e5e26e137084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gaa96a6ad46dd8363ce5d2e5e26e137084">ndlqr_PrintProfile</a> (<a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *profile)</td></tr>
<tr class="memdesc:gaa96a6ad46dd8363ce5d2e5e26e137084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a summary fo the profile.  <a href="group__rsLQR.html#gaa96a6ad46dd8363ce5d2e5e26e137084">More...</a><br /></td></tr>
<tr class="separator:gaa96a6ad46dd8363ce5d2e5e26e137084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0c0f97f396f13d034365d11bc1adfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gacf0c0f97f396f13d034365d11bc1adfb">ndlqr_CompareProfile</a> (<a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *base, <a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *prof)</td></tr>
<tr class="memdesc:gacf0c0f97f396f13d034365d11bc1adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two profiles, printing the comparison to stdout.  <a href="group__rsLQR.html#gacf0c0f97f396f13d034365d11bc1adfb">More...</a><br /></td></tr>
<tr class="separator:gacf0c0f97f396f13d034365d11bc1adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0df834b89b50395f7eef1ae9783e093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gaf0df834b89b50395f7eef1ae9783e093">ndlqr_NewNdLqrSolver</a> (int nstates, int ninputs, int nhorizon)</td></tr>
<tr class="memdesc:gaf0df834b89b50395f7eef1ae9783e093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new solver, allocating all the required memory.  <a href="group__rsLQR.html#gaf0df834b89b50395f7eef1ae9783e093">More...</a><br /></td></tr>
<tr class="separator:gaf0df834b89b50395f7eef1ae9783e093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe35971a06a3d15dccfe25d7834296a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gafe35971a06a3d15dccfe25d7834296a6">ndlqr_FreeNdLqrSolver</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:gafe35971a06a3d15dccfe25d7834296a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the memory for the solver.  <a href="group__rsLQR.html#gafe35971a06a3d15dccfe25d7834296a6">More...</a><br /></td></tr>
<tr class="separator:gafe35971a06a3d15dccfe25d7834296a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0247c6971e10113d9b77b3a282511a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga3b0247c6971e10113d9b77b3a282511a">ndlqr_InitializeWithLQRProblem</a> (const <a class="el" href="structLQRProblem.html">LQRProblem</a> *lqrprob, <a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga3b0247c6971e10113d9b77b3a282511a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver with data from an LQR Problem.  <a href="group__rsLQR.html#ga3b0247c6971e10113d9b77b3a282511a">More...</a><br /></td></tr>
<tr class="separator:ga3b0247c6971e10113d9b77b3a282511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac722267766ac9d4bc0d98683fdb92c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gac722267766ac9d4bc0d98683fdb92c2b">ndlqr_ResetSolver</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:gac722267766ac9d4bc0d98683fdb92c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the rsLQR solver.  <a href="group__rsLQR.html#gac722267766ac9d4bc0d98683fdb92c2b">More...</a><br /></td></tr>
<tr class="separator:gac722267766ac9d4bc0d98683fdb92c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7ee614703b9d0768ed30ce18068f33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#gad7ee614703b9d0768ed30ce18068f33e">ndlqr_PrintSolveSummary</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:gad7ee614703b9d0768ed30ce18068f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of the solve.  <a href="group__rsLQR.html#gad7ee614703b9d0768ed30ce18068f33e">More...</a><br /></td></tr>
<tr class="separator:gad7ee614703b9d0768ed30ce18068f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa15c5f7278b32dab9dcef25c9e1949"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga8aa15c5f7278b32dab9dcef25c9e1949">ndlqr_GetNumVars</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga8aa15c5f7278b32dab9dcef25c9e1949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of decision variables for the problem.  <a href="group__rsLQR.html#ga8aa15c5f7278b32dab9dcef25c9e1949">More...</a><br /></td></tr>
<tr class="separator:ga8aa15c5f7278b32dab9dcef25c9e1949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63cbbc40527514d57ae998350a562655"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga63cbbc40527514d57ae998350a562655">ndlqr_SetNumThreads</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver, int num_threads)</td></tr>
<tr class="memdesc:ga63cbbc40527514d57ae998350a562655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads to be used during the solve.  <a href="group__rsLQR.html#ga63cbbc40527514d57ae998350a562655">More...</a><br /></td></tr>
<tr class="separator:ga63cbbc40527514d57ae998350a562655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0bca99f1531ac94f71c719458daced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga8a0bca99f1531ac94f71c719458daced">ndlqr_GetNumThreads</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga8a0bca99f1531ac94f71c719458daced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads used during the rsLQR solve.  <a href="group__rsLQR.html#ga8a0bca99f1531ac94f71c719458daced">More...</a><br /></td></tr>
<tr class="separator:ga8a0bca99f1531ac94f71c719458daced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4491fc432e176360dcd5e8260aa0281e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga4491fc432e176360dcd5e8260aa0281e">ndlqr_PrintSolveProfile</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga4491fc432e176360dcd5e8260aa0281e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of how long individual components took.  <a href="group__rsLQR.html#ga4491fc432e176360dcd5e8260aa0281e">More...</a><br /></td></tr>
<tr class="separator:ga4491fc432e176360dcd5e8260aa0281e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190e06d756e8c2c51d77d4d8bf44a860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsLQR.html#ga190e06d756e8c2c51d77d4d8bf44a860">ndlqr_GetProfile</a> (<a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *solver)</td></tr>
<tr class="memdesc:ga190e06d756e8c2c51d77d4d8bf44a860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ge the internal profile data from a solve.  <a href="group__rsLQR.html#ga190e06d756e8c2c51d77d4d8bf44a860">More...</a><br /></td></tr>
<tr class="separator:ga190e06d756e8c2c51d77d4d8bf44a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga58621bd1feb25e3dee120e49c6451172" name="ga58621bd1feb25e3dee120e49c6451172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58621bd1feb25e3dee120e49c6451172">&#9670;&nbsp;</a></span>ndlqr_BuildTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> ndlqr_BuildTree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new binary tree for a horizon of length <code>N</code>. </p>
<p >Must be paired with a corresponding call to <a class="el" href="group__rsLQR.html#ga88f22c532856661f4d072692b803eb5d" title="Frees the data in tree.">ndlqr_FreeTree()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>horizon length. Must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new binary tree </dd></dl>

</div>
</div>
<a id="gacf0c0f97f396f13d034365d11bc1adfb" name="gacf0c0f97f396f13d034365d11bc1adfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf0c0f97f396f13d034365d11bc1adfb">&#9670;&nbsp;</a></span>ndlqr_CompareProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_CompareProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>prof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two profiles, printing the comparison to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The baseline profile </td></tr>
    <tr><td class="paramname">prof</td><td>The "new" profile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55e23fb27df1efa3aa041f76d8b42237" name="ga55e23fb27df1efa3aa041f76d8b42237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55e23fb27df1efa3aa041f76d8b42237">&#9670;&nbsp;</a></span>ndlqr_CopyProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_CopyProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the profile information to a new profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>New location for data. Existing data will be overwritten. </td></tr>
    <tr><td class="paramname">src</td><td>Data to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ec8f7acf834c55596d31eeab7502639" name="ga6ec8f7acf834c55596d31eeab7502639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec8f7acf834c55596d31eeab7502639">&#9670;&nbsp;</a></span>ndlqr_CopySolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_CopySolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>soln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the solution vector to a user-supplied array. </p>
<p >See <a class="el" href="group__rsLQR.html#ga01780b3bc4f5f408ddee594e74106f58" title="Return the solution vector.">ndlqr_GetSolution()</a> for variable order.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2" title="Solve an LQR problem using rsLQR.">ndlqr_Solve()</a> has already been called </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>The solver with the solution. </td></tr>
    <tr><td class="paramname">soln</td><td>Output location for the solution vector. Should have length at least equal to the output of <a class="el" href="group__rsLQR.html#ga8aa15c5f7278b32dab9dcef25c9e1949" title="Gets the total number of decision variables for the problem.">ndlqr_GetNumVars()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gab8b4290a3055f2e214a78189fe4ad490" name="gab8b4290a3055f2e214a78189fe4ad490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b4290a3055f2e214a78189fe4ad490">&#9670;&nbsp;</a></span>ndlqr_FactorInnerProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_FactorInnerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fact_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates one of the inner products needed at level <code>data_level</code>. </p>
<p >Calculates the following:</p>
<p class="formulaDsp">
\[ \bar{\Lambda_{k+1}^{(p)}} = \bar{\Lambda_k^{(p)}}S + \langle X_k^{(j)}, \bar{X}_k^{(p)} \rangle + \langle U_k^{(j)}, \bar{U}_k^{(p)} \rangle + \langle X_{k+1}^{(j)}, \bar{X}_{k+1}^{(p)} \rangle + \langle U_{k+1}^{(j)}, \bar{U}_{k+1}^{(p)} \rangle \]
</p>
<p >where \( j \) is <code>data_level</code>, \( p \) is <code>fact_level</code>, and \( k \) is <code>index</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data for the original KKT matrix </td></tr>
    <tr><td class="paramname">fact</td><td>The current data for the factorization </td></tr>
    <tr><td class="paramname">index</td><td>Knot point index </td></tr>
    <tr><td class="paramname">data_level</td><td>Level index for the original data, or equivalently the current level being processed by the outer solve </td></tr>
    <tr><td class="paramname">fact_level</td><td>Level index for the factorization data, or equivalently the parent or upper level. <code>fact_level</code> &gt;= <code>data_level</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga347fabdfc15bad96109ec07ac581afa8" name="ga347fabdfc15bad96109ec07ac581afa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347fabdfc15bad96109ec07ac581afa8">&#9670;&nbsp;</a></span>ndlqr_FreeCholeskyFactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_FreeCholeskyFactors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *&#160;</td>
          <td class="paramname"><em>cholfacts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory of a CholeskyFactors object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cholfacts</td><td>An initialized <a class="el" href="structNdLqrCholeskyFactors.html" title="Stores a list of CholeskyInfo structs for the rsLQR solver.">NdLqrCholeskyFactors</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>cholfacts = NULL </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga39d99f612df1652c82044835c16e96e5" name="ga39d99f612df1652c82044835c16e96e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d99f612df1652c82044835c16e96e5">&#9670;&nbsp;</a></span>ndlqr_FreeNdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_FreeNdData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>nddata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated in an <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nddata</td><td>Initialized <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="gafe35971a06a3d15dccfe25d7834296a6" name="gafe35971a06a3d15dccfe25d7834296a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe35971a06a3d15dccfe25d7834296a6">&#9670;&nbsp;</a></span>ndlqr_FreeNdLqrSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_FreeNdLqrSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the memory for the solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>An initialized solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>solver == NULL </dd></dl>

</div>
</div>
<a id="ga88f22c532856661f4d072692b803eb5d" name="ga88f22c532856661f4d072692b803eb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f22c532856661f4d072692b803eb5d">&#9670;&nbsp;</a></span>ndlqr_FreeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_FreeTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the data in <code>tree</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>An initialized binary tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="gadbb47b122d55cdbb5d44e3d61fa39c07" name="gadbb47b122d55cdbb5d44e3d61fa39c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb47b122d55cdbb5d44e3d61fa39c07">&#9670;&nbsp;</a></span>ndlqr_GetIndexAtLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetIndexAtLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index in <code>level</code> that corresponds to <code>index</code>. </p>
<p >If the level is higher than the level of the given index, it's simply the parent at that level. If it's lower, then it's the index that's closest to the given one, with ties broken by choosing the left (or smaller) of the two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Precomputed binary tree </td></tr>
    <tr><td class="paramname">index</td><td>Start index of the search. The result will be the index closest to this index. </td></tr>
    <tr><td class="paramname">level</td><td>The level in which the returned index should belong to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The index closest to the provided one, in the given level. -1 if unsucessful. </dd></dl>

</div>
</div>
<a id="ga7091ad6eed6a6a2dc0e77f6c04a54529" name="ga7091ad6eed6a6a2dc0e77f6c04a54529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7091ad6eed6a6a2dc0e77f6c04a54529">&#9670;&nbsp;</a></span>ndlqr_GetIndexFromLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetIndexFromLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the knot point index given the leaf index at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>An initialized binary tree for the problem horizon </td></tr>
    <tr><td class="paramname">leaf</td><td>Leaf index </td></tr>
    <tr><td class="paramname">level</td><td>Level of tree from which to get the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gaf2fac162ee700642c4c323bfec422a65" name="gaf2fac162ee700642c4c323bfec422a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2fac162ee700642c4c323bfec422a65">&#9670;&nbsp;</a></span>ndlqr_GetIndexLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetIndexLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the level for a given knot point index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>An initialized binary tree for the problem horizon </td></tr>
    <tr><td class="paramname">index</td><td>Knot point index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level for the given index </dd></dl>

</div>
</div>
<a id="ga9ae7f8de9bb4013d3800c5795f07930b" name="ga9ae7f8de9bb4013d3800c5795f07930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ae7f8de9bb4013d3800c5795f07930b">&#9670;&nbsp;</a></span>ndlqr_GetNdFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetNdFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>nddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdFactor.html">NdFactor</a> **&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an individual <a class="el" href="structNdFactor.html" title="A chunk of memory for a single time step.">NdFactor</a> out of the <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a>. </p>
<p >Retrieves a block of memory out of <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a>, stored as an <a class="el" href="structNdFactor.html" title="A chunk of memory for a single time step.">NdFactor</a>. Typical usage will look like:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structNdData.html">NdData</a>* ndata = <a class="code hl_function" href="group__rsLQR.html#ga48a8b869c8f653a598474393a5f95630">ndlqr_NewNdData</a>(nstates, ninputs, nhorizon, nstates);</div>
<div class="line"><a class="code hl_struct" href="structNdFactor.html">NdFactor</a>* factor;</div>
<div class="line"><span class="keywordtype">int</span> index = 0;  <span class="comment">// set to desired index</span></div>
<div class="line"><span class="keywordtype">int</span> level = 1;  <span class="comment">// set to desired level</span></div>
<div class="line"><a class="code hl_function" href="group__rsLQR.html#ga9ae7f8de9bb4013d3800c5795f07930b">ndlqr_GetNdFactor</a>(nddata, index, level, &amp;factor);</div>
<div class="ttc" id="agroup__rsLQR_html_ga48a8b869c8f653a598474393a5f95630"><div class="ttname"><a href="group__rsLQR.html#ga48a8b869c8f653a598474393a5f95630">ndlqr_NewNdData</a></div><div class="ttdeci">NdData * ndlqr_NewNdData(int nstates, int ninputs, int nhorizon, int width)</div><div class="ttdoc">Initialize the NdData structure.</div><div class="ttdef"><b>Definition:</b> nddata.c:21</div></div>
<div class="ttc" id="agroup__rsLQR_html_ga9ae7f8de9bb4013d3800c5795f07930b"><div class="ttname"><a href="group__rsLQR.html#ga9ae7f8de9bb4013d3800c5795f07930b">ndlqr_GetNdFactor</a></div><div class="ttdeci">int ndlqr_GetNdFactor(NdData *nddata, int index, int level, NdFactor **factor)</div><div class="ttdoc">Retrieve an individual NdFactor out of the NdData.</div><div class="ttdef"><b>Definition:</b> nddata.c:88</div></div>
<div class="ttc" id="astructNdData_html"><div class="ttname"><a href="structNdData.html">NdData</a></div><div class="ttdoc">Core storage container for the rsLQR solver.</div><div class="ttdef"><b>Definition:</b> nddata.h:83</div></div>
<div class="ttc" id="astructNdFactor_html"><div class="ttname"><a href="structNdFactor.html">NdFactor</a></div><div class="ttdoc">A chunk of memory for a single time step.</div><div class="ttdef"><b>Definition:</b> nddata.h:40</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nddata</td><td>Storage location for the desired block of memory </td></tr>
    <tr><td class="paramname">index</td><td>Time step of the factor to extract </td></tr>
    <tr><td class="paramname">level</td><td>Level (or column in the <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a>) of the desired factor </td></tr>
    <tr><td class="paramname">factor</td><td>Storage location for the factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga8a0bca99f1531ac94f71c719458daced" name="ga8a0bca99f1531ac94f71c719458daced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0bca99f1531ac94f71c719458daced">&#9670;&nbsp;</a></span>ndlqr_GetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetNumThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of threads used during the rsLQR solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>A solver which has already been initialized and solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of OpenMP threads used the by solver </dd></dl>

</div>
</div>
<a id="ga8aa15c5f7278b32dab9dcef25c9e1949" name="ga8aa15c5f7278b32dab9dcef25c9e1949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aa15c5f7278b32dab9dcef25c9e1949">&#9670;&nbsp;</a></span>ndlqr_GetNumVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetNumVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of decision variables for the problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga190e06d756e8c2c51d77d4d8bf44a860" name="ga190e06d756e8c2c51d77d4d8bf44a860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga190e06d756e8c2c51d77d4d8bf44a860">&#9670;&nbsp;</a></span>ndlqr_GetProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> ndlqr_GetProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ge the internal profile data from a solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>A solver which has already been initialized and solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A profile object containing timing information about the solve See <a class="el" href="structNdLqrProfile.html" title="A struct describing how long each part of the solve took, in milliseconds.">NdLqrProfile</a> for more info. </dd></dl>

</div>
</div>
<a id="gab68ab5c2128682cbf8fdd451f238a0c6" name="gab68ab5c2128682cbf8fdd451f238a0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab68ab5c2128682cbf8fdd451f238a0c6">&#9670;&nbsp;</a></span>ndlqr_GetQFactorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetQFactorizon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *&#160;</td>
          <td class="paramname"><em>cholfacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **&#160;</td>
          <td class="paramname"><em>cholfact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the matrix Q at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cholfacts</td><td>All the stored info for the Cholesky solves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Knot point index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cholfact</td><td>Location for the retrieved <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="gae2966cbba0933c886aea12854d967dd2" name="gae2966cbba0933c886aea12854d967dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2966cbba0933c886aea12854d967dd2">&#9670;&nbsp;</a></span>ndlqr_GetRFactorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetRFactorizon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *&#160;</td>
          <td class="paramname"><em>cholfacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **&#160;</td>
          <td class="paramname"><em>cholfact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the matrix R at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cholfacts</td><td>All the stored info for the Cholesky solves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Knot point index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cholfact</td><td>Location for the retrieved <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga98d1d95ede3b3b83a19f7b6edeba0a44" name="ga98d1d95ede3b3b83a19f7b6edeba0a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d1d95ede3b3b83a19f7b6edeba0a44">&#9670;&nbsp;</a></span>ndlqr_GetSFactorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_GetSFactorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> *&#160;</td>
          <td class="paramname"><em>cholfacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> **&#160;</td>
          <td class="paramname"><em>cholfact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for the output of <a class="el" href="group__rsLQR.html#ga2ab24570b3c8d44f764224ef99dfb4b6" title="Use the precomputed Cholesky factorization to solve for y at each parent level.">ndlqr_SolveCholeskyFactor()</a>. </p>
<p >Gets the <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> for \( \bar{B}_i^{(j)} \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cholfacts</td><td>All the stored info for the Cholesky solves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaf</td><td>The leaf index for the desired factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the binary tree for the factor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cholfact</td><td>Location for the retrieved <a class="el" href="structCholeskyInfo.html" title="Stores info about a Cholesky decomposition.">CholeskyInfo</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga01780b3bc4f5f408ddee594e74106f58" name="ga01780b3bc4f5f408ddee594e74106f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01780b3bc4f5f408ddee594e74106f58">&#9670;&nbsp;</a></span>ndlqr_GetSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix.html">Matrix</a> ndlqr_GetSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the solution vector. </p>
<p >Returns the solution vector as a <a class="el" href="structMatrix.html" title="Represents a matrix of double-precision data.">Matrix</a> object, which is a simple wrapper around a raw pointer which points to the data actually stored by the solver. The user must not free the data, as it is owned by the solver. To get a solution vector owned by the caller, use <a class="el" href="group__rsLQR.html#ga6ec8f7acf834c55596d31eeab7502639" title="Copies the solution vector to a user-supplied array.">ndlqr_CopySolution()</a> instead.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Variable Ordering</h2>
<p >The variables are ordered in the solution vector as follows:</p>
<p class="formulaDsp">
\[ \begin{bmatrix} \lambda_1^T &amp; x_1^T &amp; u_1^T &amp; \lambda_2^T &amp; \dots &amp; x_{N-1}^T &amp; u_{N-1}^T &amp; \lambda_N^T &amp; x_N^T \end{bmatrix}^T \]
</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2" title="Solve an LQR problem using rsLQR.">ndlqr_Solve()</a> has already been called </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga3b0247c6971e10113d9b77b3a282511a" name="ga3b0247c6971e10113d9b77b3a282511a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0247c6971e10113d9b77b3a282511a">&#9670;&nbsp;</a></span>ndlqr_InitializeWithLQRProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_InitializeWithLQRProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structLQRProblem.html">LQRProblem</a> *&#160;</td>
          <td class="paramname"><em>lqrprob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the solver with data from an LQR Problem. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Solver has already been initialized via <a class="el" href="group__rsLQR.html#gaf0df834b89b50395f7eef1ae9783e093" title="Create a new solver, allocating all the required memory.">ndlqr_NewNdLqrSolver()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lqrprob</td><td>An initialized LQR problem with the data to be be solved. </td></tr>
    <tr><td class="paramname">solver</td><td>An initialized solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga0afa3d33bd0a5a7853434a2ddf084f7e" name="ga0afa3d33bd0a5a7853434a2ddf084f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0afa3d33bd0a5a7853434a2ddf084f7e">&#9670;&nbsp;</a></span>ndlqr_NewCholeskyFactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNdLqrCholeskyFactors.html">NdLqrCholeskyFactors</a> * ndlqr_NewCholeskyFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nhorizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new <a class="el" href="structNdLqrCholeskyFactors.html" title="Stores a list of CholeskyInfo structs for the rsLQR solver.">NdLqrCholeskyFactors</a> object. </p>
<p >Must be paired with a call to <a class="el" href="group__rsLQR.html#ga347fabdfc15bad96109ec07ac581afa8" title="Free the memory of a CholeskyFactors object.">ndlqr_FreeCholeskyFactors()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Depth of the binary tree </td></tr>
    <tr><td class="paramname">nhorizon</td><td>Length of the time horizon. <code>log2</code>(@depth) = <code>nhorizon</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structNdLqrCholeskyFactors.html" title="Stores a list of CholeskyInfo structs for the rsLQR solver.">NdLqrCholeskyFactors</a> object. </dd></dl>

</div>
</div>
<a id="ga48a8b869c8f653a598474393a5f95630" name="ga48a8b869c8f653a598474393a5f95630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48a8b869c8f653a598474393a5f95630">&#9670;&nbsp;</a></span>ndlqr_NewNdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNdData.html">NdData</a> * ndlqr_NewNdData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ninputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nhorizon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure. </p>
<p >Note this allocates a large block of memory. This should be followed by a single call to <a class="el" href="group__rsLQR.html#ga39d99f612df1652c82044835c16e96e5" title="Frees the memory allocated in an NdData structure.">ndlqr_FreeNdData()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nstates</td><td>Number of variables in the state vector </td></tr>
    <tr><td class="paramname">ninputs</td><td>Number of control inputs </td></tr>
    <tr><td class="paramname">nhorizon</td><td>Length of the time horizon </td></tr>
    <tr><td class="paramname">width</td><td>With of each factor. Should be <code>nstates</code> for KKT matrix data, or 1 for the right-hand side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure </dd></dl>

</div>
</div>
<a id="gaf0df834b89b50395f7eef1ae9783e093" name="gaf0df834b89b50395f7eef1ae9783e093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0df834b89b50395f7eef1ae9783e093">&#9670;&nbsp;</a></span>ndlqr_NewNdLqrSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> * ndlqr_NewNdLqrSolver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ninputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nhorizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new solver, allocating all the required memory. </p>
<p >Must be followed by a later call to <a class="el" href="group__rsLQR.html#gafe35971a06a3d15dccfe25d7834296a6" title="Deallocates the memory for the solver.">ndlqr_FreeNdLqrSolver()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nstates</td><td>Number of elements in the state vector </td></tr>
    <tr><td class="paramname">ninputs</td><td>Number of control inputs </td></tr>
    <tr><td class="paramname">nhorizon</td><td>Length of the time horizon. Must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new solver </dd></dl>

</div>
</div>
<a id="gaa96a6ad46dd8363ce5d2e5e26e137084" name="gaa96a6ad46dd8363ce5d2e5e26e137084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96a6ad46dd8363ce5d2e5e26e137084">&#9670;&nbsp;</a></span>ndlqr_PrintProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_PrintProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>profile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a summary fo the profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4491fc432e176360dcd5e8260aa0281e" name="ga4491fc432e176360dcd5e8260aa0281e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4491fc432e176360dcd5e8260aa0281e">&#9670;&nbsp;</a></span>ndlqr_PrintSolveProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_PrintSolveProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a summary of how long individual components took. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2" title="Solve an LQR problem using rsLQR.">ndlqr_Solve()</a> has already been called </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>A solver which has already been initialized and solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="gad7ee614703b9d0768ed30ce18068f33e" name="gad7ee614703b9d0768ed30ce18068f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7ee614703b9d0768ed30ce18068f33e">&#9670;&nbsp;</a></span>ndlqr_PrintSolveSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_PrintSolveSummary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a summary of the solve. </p>
<p >Prints solve time, the residual norm, and the number of theads.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__rsLQR.html#ga3ee14a10200c2d84096964703030dda2" title="Solve an LQR problem using rsLQR.">ndlqr_Solve()</a> has already been called </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefc6e77a65cf48a86f5e951a69cfe78b" name="gaefc6e77a65cf48a86f5e951a69cfe78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefc6e77a65cf48a86f5e951a69cfe78b">&#9670;&nbsp;</a></span>ndlqr_ResetNdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_ResetNdData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>nddata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all of the memory for an <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nddata</td><td>Initialized <a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4588eb322de417b184ff7e6df976b0fe" name="ga4588eb322de417b184ff7e6df976b0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4588eb322de417b184ff7e6df976b0fe">&#9670;&nbsp;</a></span>ndlqr_ResetProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_ResetProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrProfile.html">NdLqrProfile</a> *&#160;</td>
          <td class="paramname"><em>prof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the profile to its initialized state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prof</td><td>A profile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac722267766ac9d4bc0d98683fdb92c2b" name="gac722267766ac9d4bc0d98683fdb92c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac722267766ac9d4bc0d98683fdb92c2b">&#9670;&nbsp;</a></span>ndlqr_ResetSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ndlqr_ResetSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the rsLQR solver. </p>
<p >Resets all of the data in the solver to how it was when it was first initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63cbbc40527514d57ae998350a562655" name="ga63cbbc40527514d57ae998350a562655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63cbbc40527514d57ae998350a562655">&#9670;&nbsp;</a></span>ndlqr_SetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_SetNumThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads to be used during the solve. </p>
<p >Does not guarantee that the specified number of threads will be used. To query the actual number of threads used during the solve, use the <a class="el" href="group__rsLQR.html#ga8a0bca99f1531ac94f71c719458daced" title="Get the number of threads used during the rsLQR solve.">ndlqr_GetNumThreads()</a> function after the solve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>rsLQR solver </td></tr>
    <tr><td class="paramname">num_threads</td><td>requested number of threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga7b9cd59f37a777094d6fe96711afb25c" name="ga7b9cd59f37a777094d6fe96711afb25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b9cd59f37a777094d6fe96711afb25c">&#9670;&nbsp;</a></span>ndlqr_ShouldCalcLambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ndlqr_ShouldCalcLambda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOrderedBinaryTree.html">OrderedBinaryTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the \( \Lambda \) should be updated during ndlqr_UpdateSchurFactor() </p>
<p >Basically checks to see if the \( \Lambda \) for the given index is a $B_i^{(p)}$ for any level greater than or equal to the current level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree with cached information about the structure of the problem </td></tr>
    <tr><td class="paramname">index</td><td>Knot point index calculated using <a class="el" href="group__rsLQR.html#gadbb47b122d55cdbb5d44e3d61fa39c07" title="Get the index in level that corresponds to index.">ndlqr_GetIndexAtLevel()</a> </td></tr>
    <tr><td class="paramname">i</td><td>Knot point index being processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga3ee14a10200c2d84096964703030dda2" name="ga3ee14a10200c2d84096964703030dda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee14a10200c2d84096964703030dda2">&#9670;&nbsp;</a></span>ndlqr_Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve an LQR problem using rsLQR. </p>
<p >This is the main method of the package. Using the data already allocated in the solver, this first calculates the factorization of the matrix data and then solves for solution vector. Note that calling this method twice will not result in the same data since it replaces the original right-hand-side data with the solution vector.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Extracting the solution</h2>
<p >The solution can be retrieved after the solve by calling either <a class="el" href="group__rsLQR.html#ga01780b3bc4f5f408ddee594e74106f58" title="Return the solution vector.">ndlqr_GetSolution()</a> or <a class="el" href="group__rsLQR.html#ga6ec8f7acf834c55596d31eeab7502639" title="Copies the solution vector to a user-supplied array.">ndlqr_CopySolution()</a>.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Calling solve multiple times</h2>
<p >If you want to call this method multiple times on the same data (e.g. when benchmarking solve times), use <a class="el" href="group__rsLQR.html#gaefc6e77a65cf48a86f5e951a69cfe78b" title="Resets all of the memory for an NdData to zero.">ndlqr_ResetNdData()</a> between solves to reset the factorization data. Then re-initialize the solver with the problem data via <a class="el" href="group__rsLQR.html#ga3b0247c6971e10113d9b77b3a282511a" title="Initialize the solver with data from an LQR Problem.">ndlqr_InitializeWithLQRProblem()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>An nsLQR solver that has been initialized with the desired problem data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="ga2ab24570b3c8d44f764224ef99dfb4b6" name="ga2ab24570b3c8d44f764224ef99dfb4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ab24570b3c8d44f764224ef99dfb4b6">&#9670;&nbsp;</a></span>ndlqr_SolveCholeskyFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_SolveCholeskyFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCholeskyInfo.html">CholeskyInfo</a> *&#160;</td>
          <td class="paramname"><em>cholinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the precomputed Cholesky factorization to solve for y at each parent level. </p>
<p >Solve the following linear system of equations, overwriting the right-hand-side.</p>
<p class="formulaDsp">
\[ \bar{\Lambda}_{k+1}^{(j)} y = \bar{\Lambda}_{k+1}^{(p)} \]
</p>
<p >where \( j \) is <code>level</code>, \( p \) is <code>upper_level</code>, and \( k \) is <code>index</code>.</p>
<p >This is the same as solving</p>
<p class="formulaDsp">
\[ -\bar{B}_i^{(j)} y_i^{(j,p)} = \bar{b}_i^{(j,p)} \]
</p>
<p >using the notation from the paper.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fact</td><td>Data for the factorization </td></tr>
    <tr><td class="paramname">cholinfo</td><td>Cached Cholesky factorization for \( \bar{\Lambda}_{k+1}^{(j)} \). </td></tr>
    <tr><td class="paramname">index</td><td>Knot point index. Should be calculated using <a class="el" href="group__rsLQR.html#ga7091ad6eed6a6a2dc0e77f6c04a54529" title="Get the knot point index given the leaf index at a given level.">ndlqr_GetIndexFromLeaf()</a>. </td></tr>
    <tr><td class="paramname">level</td><td>Level index for the level currently being processed by the upper-level solve. </td></tr>
    <tr><td class="paramname">upper_level</td><td>Level index for the right-hand-side. <code>upper_level</code> &gt; <code>level</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga87139e9514629e7e355f75f3267e72dc" name="ga87139e9514629e7e355f75f3267e72dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87139e9514629e7e355f75f3267e72dc">&#9670;&nbsp;</a></span>ndlqr_SolveLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_SolveLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdLqrSolver.html">NdLqrSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve all the equations for the lowest-level diagonal blocks, by timestep. </p>
<p >Called at the beginning of the solve, this method calculates the initial pieces of the factorization needed to start the recursion up through the rest of the levels. For and LQR problem, it calculates</p>
<p class="formulaDsp">
\[ Q_k^{-1} A_k^T Q_k^{-1} q_k R_k^{-1} B_k^T R_k^{-1} r_k \]
</p>
<p >for each index \( k \), with special-casing applied to the first and last indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>An initialized rsLQR solver </td></tr>
    <tr><td class="paramname">index</td><td>Knotpoint index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>

</div>
</div>
<a id="ga92f6b5fe4556a7ea57686566d0922ff9" name="ga92f6b5fe4556a7ea57686566d0922ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f6b5fe4556a7ea57686566d0922ff9">&#9670;&nbsp;</a></span>ndlqr_UpdateShurFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ndlqr_UpdateShurFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNdData.html">NdData</a> *&#160;</td>
          <td class="paramname"><em>soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calc_lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \( x \) and \( z \) to complete the factorization at the current level. </p>
<p >Calculates the following</p>
<p class="formulaDsp">
\[ \bar{\Lambda}_k^{(p)} = \bar{\Lambda}_k^{(p)} - \bar{\Lambda}_k^{(j)} \bar{\Lambda}_{k_\text{sep}}^{(p)} \bar{X}_k^{(p)} = \bar{X}_k^{(p)} - \bar{X}_k^{(j)} \bar{\Lambda}_{k_\text{sep}}^{(p)} \bar{U}_k^{(p)} = \bar{U}_k^{(p)} - \bar{U}_k^{(j)} \bar{\Lambda}_{k_\text{sep}}^{(p)} \]
</p>
<p >where \( \bar{\Lambda}_{k_\text{sep}}^{(p)} \) is equivalent to $y_i^{(j,p)}$ from the paper and is the result of the <a class="el" href="group__rsLQR.html#ga2ab24570b3c8d44f764224ef99dfb4b6" title="Use the precomputed Cholesky factorization to solve for y at each parent level.">ndlqr_SolveCholeskyFactor()</a> for <code>index</code>, <code>level</code>, and <code>upper_level</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fact</td><td><a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> for the factorization data </td></tr>
    <tr><td class="paramname">soln</td><td><a class="el" href="structNdData.html" title="Core storage container for the rsLQR solver.">NdData</a> for the factorization data or solution vector </td></tr>
    <tr><td class="paramname">index</td><td>Knot point index of the "separator" at level <code>level</code>. Should be calculated using ndlqr_GetIndexAtlevel(). </td></tr>
    <tr><td class="paramname">i</td><td>Knot point index to be processed </td></tr>
    <tr><td class="paramname">level</td><td>Level index for the level currently being processed </td></tr>
    <tr><td class="paramname">upper_level</td><td>Level index of the upper level. <code>upper_level</code> &gt; <code>level</code> </td></tr>
    <tr><td class="paramname">calc_lambda</td><td>Whether the \( \Lambda \) factor should be updated. This should be calculated using <a class="el" href="group__rsLQR.html#ga7b9cd59f37a777094d6fe96711afb25c" title="Determines if the  should be updated during ndlqr_UpdateSchurFactor()">ndlqr_ShouldCalcLambda()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
